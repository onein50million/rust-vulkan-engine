#version 450
#extension GL_EXT_debug_printf : enable
#include "extras.glsl"
layout(local_size_x = 8, local_size_y =8, local_size_z = 1) in;

layout(push_constant) uniform PushConstants{ //Co-opting some of the push constants
    mat4 cubemap_view; //This is actually the cubemap's view matrix
    mat4 view_inverse; //I'm actually sending the inverse of the view transform to the compute shader instead
    mat4 proj;
    int texture_index;
    float constant;
} pushConstant;

layout(set = 0, binding = 2, rgba8) uniform image2D outImage;
layout(binding = 4) uniform sampler2D depth_buffer;

struct Ray{
    vec3 origin;
    vec3 direction;
};
vec3 rayAt(Ray ray, float ratio){
    return ray.origin + ray.direction*ratio;
}

float map_range_linear(float value,
float fromMin,
float fromMax,
float toMin,
float toMax )
{
    float result = clamp(toMin + ((value - fromMin) / (fromMax - fromMin)) * (toMax - toMin), min(toMin,toMax), max(toMax,toMin));
    return result;
}

float linearize_depth(float d,float zNear,float zFar)
{
    return zNear * zFar / (zFar + d * (zNear - zFar));
}

//Gets how far a ray is inside a sphere
//vec2(close_hit, far_hit)
vec2 ray_sphere_depth(vec3 center, float radius, Ray ray){

    vec3 origin_center = ray.origin - center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(origin_center, ray.direction);
    float c = dot(origin_center,origin_center) - radius*radius;
    float discriminant = b*b - 4*a*c;
    if(discriminant < 0){
        return vec2(-1.0);
    }else{
        return vec2(
            (-b - sqrt(discriminant) ) / (2.0*a),
            (-b + sqrt(discriminant) ) / (2.0*a)
        );
    }
}


vec3 unproject_point(vec3 point){

//    mat4 new_transform = mat4(
//    1.0f,  0.0f, 0.0f, 0.0f,
//    0.0f, -1.0f, 0.0f, 0.0f,
//    0.0f,  0.0f, 0.5f, 0.0f,
//    0.0f,  0.0f, 0.5f, 1.0f);
//    new_transform = new_transform * pushConstant.proj;

    mat4 new_transform = pushConstant.proj;

    float inverse_denom = new_transform[2][3] / (point.z + new_transform[2][2]);
    return vec3(point.x * inverse_denom / new_transform[0][0],point.y * inverse_denom / new_transform[1][1],-inverse_denom);
//    float inverse_denom = pushConstant.proj[2][3] / (point.z + pushConstant.proj[2][2]);
//    return vec3(point.x * inverse_denom / pushConstant.proj[0][0],point.y * inverse_denom / pushConstant.proj[1][1],-inverse_denom);
}

float altitude_ratio(vec3 point){
    return length((point - PLANET_SIZE * normalize(point)) / ATMOSPHERE_ELEVATION);
}



vec3 transform_vector(vec3 vector, mat4 matrix, float w){
    return (matrix * vec4(vector,w)).xyz;
}


float density_at(vec3 point){
    float altitude_ratio = altitude_ratio(point);
    return pow(100.0, -altitude_ratio);
}

void main()
{
    vec4 out_color = vec4(0.0);
//    vec2 screen_ratio = vec2(vec2(gl_GlobalInvocationID.xy)/vec2(gl_NumWorkGroups.xy));

//    float mouse_distance = distance(vec2(gl_GlobalInvocationID.xy), ubos.mouse_position);
//    if (mouse_distance < 2.0){
////        out_color = vec4(vec3(1.0,0.2,0.2),1.0 - clamp(mouse_distance/0.01, 0.0,1.0));
//        out_color = vec4(1.0);
//    }

    //atmosphere

    vec2 resolution = imageSize(outImage);
    vec2 screen_ratio = (gl_GlobalInvocationID.xy)/resolution.xy;

    if(ubos.map_mode == 0){
        vec3 origin = (pushConstant.view_inverse * vec4(vec3(0.0), 1.0)).xyz;

        vec3 screen_space_target = vec3(screen_ratio.x * 2.0 - 1.0, screen_ratio.y * 2.0 - 1.0, 1.0);

        vec4 v4_target = pushConstant.cubemap_view * vec4(unproject_point(screen_space_target.xyz), 0.0);
        //    v4_target.z *= -1.0;
        //    target.x *    = -1.0;
        //    v4_target.z = (v4_target.z + v4_target.w) / 2.0;

        vec3 target = normalize(v4_target.xyz);

        Ray ray = Ray(origin, target);

        vec3 sun_color = vec3(1.0, 0.9, 0.2);
        vec3 sun_direction = -vec3(sin(ubos.time.x), 0.0, cos(ubos.time.x));

        //    float screen_depth = linearize_depth(texture(depth_buffer,screen_ratio).r, near, far);

        vec2 planet_hit = ray_sphere_depth(vec3(0.0), PLANET_SIZE, ray);
        float sun_dot_product = dot(-sun_direction, target);
        float sun_angle = acos(sun_dot_product);
        //    float sun_brightness = pow(map_range_linear(sun_dot_product,1.0, 0.99, 1.1,0.0),1.0);
        float sun_brightness = pow(map_range_linear(sun_angle, 0.0, 0.1, 1.0, 0.0), 10.0);

        float num_color_samples = 0.0;

        float atmosphere_cutoff = planet_hit.x;
        if (planet_hit.x < 0.0){
            atmosphere_cutoff = 1.0/0.0;//Infinity
            out_color.rgb += sun_color * 1.0 * sun_brightness;
            out_color.a += 1.0 * sun_brightness;
            num_color_samples += 1.0;
        }
        vec2 cloud_hit = ray_sphere_depth(vec3(0.0), CLOUD_SIZE, ray);
        if (cloud_hit.x > 0.0){
            vec3 cloud_position = rayAt(ray, cloud_hit.x);

            Ray cloud_sun_ray = Ray(cloud_position, -sun_direction);
            vec2 cloud_planet_hit = ray_sphere_depth(vec3(0.0), PLANET_SIZE, cloud_sun_ray);

            if (cloud_planet_hit.x < 0.0){
                float cloud_density = cloudAt(transform_vector(cloud_position, inverse(ubos.planet_model_matrix), 1.0));

                if (cloud_density > 0.001){
                    float cloud_shading = clamp(dot(normalize(cloud_position), -sun_direction), 0.0, 1.0);
                    out_color.a += cloud_density * cloud_shading;
                    out_color.rgb += vec3(1.0) * cloud_density * cloud_shading;
                    num_color_samples += cloud_density * cloud_shading;
                }


            }
        }



        vec2 ray_result = ray_sphere_depth(vec3(0.0), ATMOSPHERE_SIZE, ray);
        float atmosphere_intersection_thickness = min(ray_result.y - ray_result.x, atmosphere_cutoff - ray_result.x);
        if (atmosphere_intersection_thickness > 0.0){


            float sun_hits = 0.0;
            const int SAMPLES = 100;

            float total_particles = 0.0;

            for (int i = 0; i < SAMPLES; i++){
                vec3 hit_position = rayAt(ray, ray_result.x + (atmosphere_intersection_thickness / float(SAMPLES)) * i);
                total_particles += density_at(hit_position);
                Ray atmosphere_ray = Ray(hit_position, -sun_direction);
                vec2 atmosphere_planet_hit = ray_sphere_depth(vec3(0.0), PLANET_SIZE, atmosphere_ray);
                sun_hits += float(atmosphere_planet_hit.x < 0.0);
            }
            float average_particles = total_particles / float(SAMPLES);


            //        vec3 atmosphere_color = vec3(int(atmosphere_planet_hit.x < 0.0));
            //        vec3 atmosphere_color = vec3(0.05, 0.01, 0.5);
            //        vec3 atmosphere_color = mix(vec3(0.9,0.9,1.0), vec3(0.05,0.01, 0.5), );
            vec3 atmosphere_color = mix(vec3(1.0, 1.0, 1.0), vec3(0.00, 50.0/255.0, 255.0/255.0), altitude_ratio(rayAt(ray, ray_result.x)) + 0.1);
            float sun_mix = float((planet_hit.x < 0.0)) * pow(clamp(dot(target, -sun_direction), 0.0, 1.0), 20.0);
            atmosphere_color = mix(atmosphere_color, sun_color, sun_mix);
            out_color.rgb += atmosphere_color;
            out_color.a += average_particles * (sun_hits / float(SAMPLES));
            num_color_samples += 1.0;

        }


        //    out_color = vec4(vec3(sin(ubos.time)),1.0);
        out_color.rgb = out_color.rgb/num_color_samples;
        //    out_color = vec4(0.0);
    }
    imageStore(outImage, ivec2(gl_GlobalInvocationID.xy),out_color);
}