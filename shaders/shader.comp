#version 450
layout(local_size_x = 8, local_size_y =8, local_size_z = 1) in;

const bool RAYTRACING_ENABLED = true;

const int NUM_MODELS = 100;
const int NUM_RANDOM = 100;
const uint TYPE_SPHERE = 0;
const uint TYPE_BOX = 1;

const uint MAX_BOUNCES = 5;

const uint SAMPLE_WIDTH = 1;
const uint SAMPLE_COUNT = SAMPLE_WIDTH*SAMPLE_WIDTH;

layout(binding = 0) uniform UniformBufferObject {
    mat4 model[NUM_MODELS];
    mat4 view[NUM_MODELS];
    mat4 proj[NUM_MODELS];
    float random[NUM_RANDOM];
    int player_index;
    int value2;
    int value3;
    int value4;
} ubos;

layout(push_constant) uniform PushConstants{
    int uniform_index;
    int texture_index;
} pushConstant;

layout(binding = 2, rgba8) uniform image2D outImage;

struct Ray{
    vec3 origin;
    vec3 direction;
};

struct RayResult{
    vec3 color;
    vec3 position;
    vec3 normal;
    bool is_light;
    float light_power;
};

struct Hittable{
    uint type;
    mat4 data; //Might be a better way to do this
};

vec3 camera_location(vec3 position){
    mat4 ubo = inverse(ubos.view[pushConstant.uniform_index]);

    return (ubo * vec4(position,1.0)).xyz;
}

vec3 rayAt(Ray ray, float ratio){
    return ray.origin + ray.direction*ratio;
}
float hit_sphere(vec3 center, float radius, Ray ray){
//    center = camera_location(center);

    //TODO: Learn vector algebra
    vec3 origin_center = ray.origin - center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(origin_center, ray.direction);
    float c = dot(origin_center,origin_center) - radius*radius;
    float discriminant = b*b - 4*a*c;
    if(discriminant < 0){
        return -1.0;
    }else{
        return (-b - sqrt(discriminant) ) / (2.0*a);
    }
}

float hit_box(vec3 position, float size, Ray ray) {
    float tmin = -1.0/0.0;
    float tmax = 1.0/0.0;

    for(int axis = 0; axis < 3; axis++){
        float invD = 1.0/ray.direction[axis];
        float t0 = (position[axis] - ray.origin[axis]) * invD;
        float t1 = (position[axis] + size - ray.origin[axis]) * invD;
//        if(invD < 0.0){
//            float temp = t0;
//            t0 = t1;
//            t1 = temp;
//        }
        tmin = max(min(t0,t1), tmin);
        tmax = min(max(t0,t1), tmax);

        if (tmax <= tmin){
            return -1.0;
        }

    }
    return min(tmin,tmax);
}

vec3 sphere_normals(vec3 center, vec3 hit_position) {
    return normalize(hit_position - center);
}

vec3 box_normals(vec3 position, float size, vec3 hit_position) {
    vec3 relative_position = (hit_position - ( size*0.5 + position))*2.0 / size;
    vec3 clipped = step(0.99999, abs(relative_position));

    vec3 out_normal = mix(relative_position, clipped, 1.0);
    return out_normal;
}




float hit(Ray ray, Hittable hittable){
    return mix(hit_sphere((hittable.data[1].xyz),hittable.data[0].x, ray),hit_box(hittable.data[1].xyz, hittable.data[0].x, ray),hittable.type);
}

vec3 get_normals(vec3 position, Hittable hittable){
    return mix(sphere_normals(hittable.data[1].xyz, position),box_normals(hittable.data[1].xyz, hittable.data[0].x, position),hittable.type);

}


RayResult castRay(Ray ray){

    vec4 player_position = ubos.model[ubos.player_index]*vec4(0.0,0.0,0.0,1.0);

    Hittable hittables[5] = Hittable[5](
    Hittable(0,
    mat4(
    0.5, 0.0, 0.0, 0.0,
    player_position.xyz, 0.0,
    1.0, 1.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 0.0
    )
    ),
    Hittable(0,
    mat4(
    1.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0,
    1.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0
    )
    ),
    Hittable(0,
    mat4(
    1.0, 0.0, 0.0, 0.0,
    5.0, 0.0, 0.0, 0.0,
    0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0
    )
    ),
    Hittable(0,
    mat4(
    1.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 5.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 0.0
    )
    ),
    Hittable(0,
    mat4(
    1.0, 0.0, 0.0, 0.0,
    5.0, 5.0, 5.0, 0.0,
    1.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0
    )
    )
    );

    const int NUM_SHAPES_WIDTH = 10;
    const int NUM_SHAPES = NUM_SHAPES_WIDTH * NUM_SHAPES_WIDTH;
    Hittable test_shapes[NUM_SHAPES];

    float closest_distance = 1.0/0.0; //infinity
    RayResult result;
    bool found = false;
    for(int i = 0; i < hittables.length(); i++){
        float hit_result = hit(ray, hittables[i]);
        if (hit_result > 0.0 && hit_result < closest_distance){
            closest_distance = hit_result;
            found = true;
            vec3 normal = get_normals(rayAt(ray,hit_result),hittables[i]);
            result = RayResult(hittables[i].data[2].xyz,rayAt(ray,hit_result),normal,false, 0.0);
        }
    }

    for(int i = 0; i < NUM_SHAPES; i++){

        const int cube_size = 100;

        Hittable test_shape =
                Hittable(TYPE_BOX,
                mat4(
                cube_size, 0.0, 0.0, 0.0,
                (i % NUM_SHAPES_WIDTH) * cube_size, 1.0, (i / NUM_SHAPES_WIDTH) * cube_size, 0.0,
                0.1,0.8,0.1, 0.0,
                //                ubos.random[(i*3) % NUM_RANDOM], ubos.random[(i*3+1) % NUM_RANDOM], ubos.random[(i*3+2) % NUM_RANDOM], 0.0, //slow
                0.0, 0.0, 0.0, 0.0
                ));

        float hit_result = hit(ray, test_shape);
        if (hit_result > 0.0 && hit_result < closest_distance){
            closest_distance = hit_result;
            found = true;
            vec3 normal = get_normals(rayAt(ray,hit_result),test_shape);
            result = RayResult(test_shape.data[2].xyz,rayAt(ray,hit_result),normal,false, 0.0);
        }
    }

    if(found){
        return result;
    }

    vec3 sun_position = normalize(vec3(0.0,-0.2,1.0));
    float sun_radius = 0.1;
    float distance_to_sun = distance(normalize(ray.direction), (sun_position));
    vec3 sky_color = mix(vec3(0.26, 0.42, 0.70), vec3(0.02, 0.04, 0.07), distance_to_sun*0.5);
    vec3 sun_color = vec3(0.97, 0.80, 0.59);
    float sky_light_power = 10.0;
    float sun_light_power = 100.0;

    float lerp_ratio = min(1.0,pow(sun_radius / distance_to_sun,10));

    return RayResult(
    mix(sky_color,sun_color,lerp_ratio),
    vec3(0.0),
    vec3(0.0),
    true,
    mix(sky_light_power, sun_light_power, lerp_ratio));

}


void main()
{

    if(!RAYTRACING_ENABLED){
        imageStore(outImage, ivec2(gl_GlobalInvocationID.xy),vec4(0.0));
        return;
    }

    vec3 resolution = gl_NumWorkGroups * gl_WorkGroupSize;
//    vec3 resolution = vec3(800,600,1);
    float aspect_ratio = resolution.x/resolution.y;
    vec4 out_color = vec4(0.0);

    float focal_length = 1.0;


    float viewport_height = 2.0;
    vec2 viewport_size = vec2(viewport_height * aspect_ratio, viewport_height);

    vec3 horizontal = (vec3(viewport_size.x,0.0,0.0));
    vec3 vertical = (vec3(0.0,viewport_size.y,0.0));
    vec3 origin = (vec3(0.0,0.0,0.0));
    vec3 upper_left_corner = (-horizontal/2.0 - vertical/2.0 - vec3(0.0,0.0,focal_length));

    float sample_size = 1.0/SAMPLE_COUNT;

    float exposure = 10.0;

    vec4 samples[SAMPLE_COUNT];

    for(int current_sample = 0; current_sample < SAMPLE_COUNT; current_sample++){
        vec2 sample_coord = vec2(current_sample % (SAMPLE_WIDTH), current_sample / (SAMPLE_WIDTH));
        vec2 offset = sample_size*sample_coord - sample_size;
        vec2 screen_ratio = (gl_GlobalInvocationID.xy + offset)/resolution.xy;

        origin = (camera_location(vec3(0.0)));
        vec3 target = (inverse(ubos.view[3]) * vec4(upper_left_corner + screen_ratio.x * horizontal + screen_ratio.y * vertical,1.0)).xyz;
//        vec3 target = vec3(0.0,0.0,1.0);
        samples[current_sample] = vec4(0.0,0.0,0.0,1.0);
        vec4 last_albedo = vec4(0.0,0.0,0.0,1.0);

        for(int i = 0; i<MAX_BOUNCES; i++){
            Ray ray = Ray((origin),(target));
            RayResult ray_result = castRay(ray);

//            samples[current_sample] = vec4((ray_result.normal + 1.0)/2.0, 1.0);
            float power = ray_result.light_power * pow(1.0, i);
            if (ray_result.is_light){
                if(i <= 0){
                    samples[current_sample] = vec4(ray_result.color*power/exposure,1.0);
                }else{
                    samples[current_sample] = vec4(( ray_result.color*power/exposure),1.0) * vec4(last_albedo.xyz * pow(0.5, i),1.0);
                }
                break;
            }
            last_albedo = vec4(ray_result.color,1.0);
            target = (ray.direction - 2*dot(ray.direction, ray_result.normal)*ray_result.normal);
            origin = ray_result.position;
            vec3 random_vector = vec3(0.0);
            random_vector.x = (ubos.random[((gl_GlobalInvocationID.x * gl_GlobalInvocationID.y) + current_sample*56) % NUM_RANDOM] - 0.5)*2.0;
            random_vector.y = (ubos.random[((gl_GlobalInvocationID.x * gl_GlobalInvocationID.y + 1) + current_sample*32) % NUM_RANDOM] - 0.5)*2.0;
            random_vector.z = (ubos.random[((gl_GlobalInvocationID.x * gl_GlobalInvocationID.y + 2 ) + current_sample*123) % NUM_RANDOM] - 0.5)*2.0;
            random_vector = normalize(random_vector);

            target += (random_vector*0.1);
        }
    }


    vec4 sum = vec4(0.0);
    for(int i = 0; i < SAMPLE_COUNT; i++){
        sum += samples[i];
    }

    out_color = sum/SAMPLE_COUNT;

    imageStore(outImage, ivec2(gl_GlobalInvocationID.xy),out_color);

}